// Generated by CoffeeScript 1.6.2
var EventEmitter, TaskGroup, Watcher, balUtil, createWatcher, eachr, extendr, fsUtil, pathUtil, safefs, typeChecker, watch, watchers, watchersTotal,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

pathUtil = require('path');

fsUtil = require('fs');

balUtil = require('bal-util');

safefs = require('safefs');

extendr = require('extendr');

eachr = require('eachr');

typeChecker = require('typechecker');

TaskGroup = require('taskgroup').TaskGroup;

EventEmitter = require('events').EventEmitter;

/*
Now to make watching files more convient and managed, we'll create a class which we can use to attach to each file.
It'll provide us with the API and abstraction we need to accomplish difficult things like recursion.
We'll also store a global store of all the watchers and their paths so we don't have multiple watchers going at the same time
for the same file - as that would be quite ineffecient.
Events:
- `log` for debugging, receives the arguments `logLevel ,args...`
- `error` for gracefully listening to error events, receives the arguments `err`
- `watching` for when watching of the path has completed, receives the arguments `err, watcherInstance, isWatching`
- `change` for listening to change events, receives the arguments `changeType, fullPath, currentStat, previousStat`
*/


watchersTotal = 0;

watchers = {};

Watcher = (function(_super) {
  __extends(_Class, _super);

  _Class.prototype.path = null;

  _Class.prototype.isDirectory = null;

  _Class.prototype.stat = null;

  _Class.prototype.fswatcher = null;

  _Class.prototype.children = null;

  _Class.prototype.state = 'pending';

  _Class.prototype.method = null;

  _Class.prototype.config = {
    path: null,
    listener: null,
    listeners: null,
    stat: null,
    outputLog: false,
    interval: 5007,
    persistent: true,
    duplicateDelay: 1 * 1000,
    preferredMethods: null,
    ignorePaths: false,
    ignoreHiddenFiles: false,
    ignoreCommonPatterns: true,
    ignoreCustomPatterns: null
  };

  function _Class(config, next) {
    this.listener = __bind(this.listener, this);
    this.bubbler = __bind(this.bubbler, this);
    this.bubble = __bind(this.bubble, this);
    this.isIgnoredPath = __bind(this.isIgnoredPath, this);
    this.log = __bind(this.log, this);    this.children = {};
    this.config = extendr.extend({}, this.config);
    this.config.preferredMethods = ['watch', 'watchFile'];
    if (config.next != null) {
      if (next == null) {
        next = config.next;
      }
      delete config.next;
    }
    if (config) {
      this.setup(config);
    }
    if (next) {
      this.watch(next);
    }
    this;
  }

  _Class.prototype.log = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (this.config.outputLog) {
      console.log.apply(console, args);
    }
    this.emit.apply(this, ['log'].concat(__slice.call(args)));
    return this;
  };

  _Class.prototype.isIgnoredPath = function(path, opts) {
    var ignore, _ref, _ref1, _ref2, _ref3;

    if (opts == null) {
      opts = {};
    }
    ignore = balUtil.isIgnoredPath(path, {
      ignorePaths: (_ref = opts.ignorePaths) != null ? _ref : this.config.ignorePaths,
      ignoreHiddenFiles: (_ref1 = opts.ignoreHiddenFiles) != null ? _ref1 : this.config.ignoreHiddenFiles,
      ignoreCommonPatterns: (_ref2 = opts.ignoreCommonPatterns) != null ? _ref2 : this.config.ignoreCommonPatterns,
      ignoreCustomPatterns: (_ref3 = opts.ignoreCustomPatterns) != null ? _ref3 : this.config.ignoreCustomPatterns
    });
    this.log('debug', "ignore: " + path + " " + (ignore ? 'yes' : 'no'));
    return ignore;
  };

  /*
  	Setup our Instance
  */


  _Class.prototype.setup = function(config) {
    extendr.extend(this.config, config);
    this.path = this.config.path;
    if (this.config.stat) {
      this.stat = this.config.stat;
      this.isDirectory = this.stat.isDirectory();
      delete this.config.stat;
    }
    if (this.config.listener || this.config.listeners) {
      this.removeAllListeners();
      if (this.config.listener) {
        this.listen(this.config.listener);
        delete this.config.listener;
      }
      if (this.config.listeners) {
        this.listen(this.config.listeners);
        delete this.config.listeners;
      }
    }
    return this;
  };

  _Class.prototype.bubble = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    this.emit.apply(this, args);
    return this;
  };

  _Class.prototype.bubbler = function(eventName) {
    var _this = this;

    return function() {
      var args;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return _this.bubble.apply(_this, [eventName].concat(__slice.call(args)));
    };
  };

  /*
  	Listen
  	Add listeners to our watcher instance.
  	Overloaded to also accept the following:
  	- `changeListener` a single change listener
  	- `[changeListener]` an array of change listeners
  	- `{eventName:eventListener}` an object keyed with the event names and valued with a single event listener
  	- `{eventName:[eventListener]}` an object keyed with the event names and valued with an array of event listeners
  */


  _Class.prototype.listen = function(eventName, listener) {
    var listenerArray, listeners, _i, _j, _len, _len1;

    if (listener == null) {
      listeners = eventName;
      if (typeChecker.isArray(listeners)) {
        for (_i = 0, _len = listeners.length; _i < _len; _i++) {
          listener = listeners[_i];
          this.listen('change', listener);
        }
      } else if (typeChecker.isPlainObject(listeners)) {
        for (eventName in listeners) {
          if (!__hasProp.call(listeners, eventName)) continue;
          listenerArray = listeners[eventName];
          if (typeChecker.isArray(listenerArray)) {
            for (_j = 0, _len1 = listenerArray.length; _j < _len1; _j++) {
              listener = listenerArray[_j];
              this.listen(eventName, listener);
            }
          } else {
            this.listen(eventName, listenerArray);
          }
        }
      } else {
        this.listen('change', listeners);
      }
    } else {
      this.removeListener(eventName, listener);
      this.on(eventName, listener);
      this.log('debug', "added a listener: on " + this.path + " for event " + eventName);
    }
    return this;
  };

  /*
  	Emit Safe
  	Sometimes events can fire incredibly quickly in which case we'll determine multiple events
  	This alias for emit('change',...) will check to see if the event has already been fired recently
  	and if it has, then ignore it
  */


  _Class.prototype.cacheTimeout = null;

  _Class.prototype.cachedEvents = null;

  _Class.prototype.emitSafe = function() {
    var args, config, me, thisEvent, _ref;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    me = this;
    config = this.config;
    if (config.duplicateDelay) {
      if (this.cacheTimeout != null) {
        clearTimeout(this.cacheTimeout);
      }
      this.cacheTimeout = setTimeout(function() {
        me.cachedEvents = [];
        return me.cacheTimeout = null;
      }, config.duplicateDelay);
      if ((_ref = this.cachedEvents) == null) {
        this.cachedEvents = [];
      }
      thisEvent = JSON.stringify(args);
      if (__indexOf.call(this.cachedEvents, thisEvent) >= 0) {
        this.log('debug', "event ignored on " + this.path + " due to duplicate:", args);
        return this;
      }
      this.cachedEvents.push(thisEvent);
    }
    this.emit.apply(this, args);
    return this;
  };

  /*
  	Listener
  	A change event has fired
  
  	Things to note:
  	- watchFile:
  		- currentStat still exists even for deleted/renamed files
  		- for deleted and updated files, it will fire on the file
  		- for created files, it will fire on the directory
  	- fsWatcher:
  		- eventName is either 'change' or 'rename', this value cannot be trusted
  		- currentStat still exists even for deleted/renamed files
  		- previousStat is accurate, however we already have this
  		- for deleted and changed files, it will fire on the file
  		- for new files, it will fire on the directory
  
  	Arguments for our change listener will be:
  	- for updated files the arguments will be: `'update', fullPath, currentStat, previousStat`
  	- for created files the arguments will be: `'create', fullPath, currentStat, null`
  	- for deleted files the arguments will be: `'delete', fullPath, null, previousStat`
  
  	In the future we will add:
  	- for renamed files: 'rename', fullPath, currentStat, previousStat, newFullPath
  	- rename is possible as the stat.ino is the same for the delete and create
  */


  _Class.prototype.listener = function() {
    var args, currentStat, determineTheChange, fileExists, fileFullPath, isTheSame, me, previousStat,
      _this = this;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    me = this;
    fileFullPath = this.path;
    currentStat = null;
    previousStat = this.stat;
    fileExists = null;
    this.log('debug', "watch event triggered on " + this.path + ":", args);
    if (args[0] === 'change' && this.children[args[1]]) {
      return (function() {
        var childFileRelativePath, childFileWatcher;

        childFileRelativePath = args[1];
        childFileWatcher = _this.children[args[1]];
        _this.log('debug', 'forwarding initial change detection to child:', childFileRelativePath, 'via:', fileFullPath);
        return childFileWatcher.listener('change', '.');
      })();
    }
    isTheSame = function() {
      if ((currentStat != null) && (previousStat != null)) {
        if (currentStat.size === previousStat.size && currentStat.mtime.toString() === previousStat.mtime.toString()) {
          return true;
        }
      }
      return false;
    };
    determineTheChange = function() {
      if (!fileExists) {
        _this.log('debug', 'determined delete:', fileFullPath);
        return _this.close('deleted');
      } else {
        if (isTheSame()) {
          return _this.log('debug', "determined same:", fileFullPath);
        } else {
          if (_this.isDirectory) {
            if (isTheSame() === false) {
              return safefs.readdir(fileFullPath, function(err, newFileRelativePaths) {
                if (err) {
                  return _this.emit('error', err);
                }
                if (typeChecker.isString(args[0]) && args[1] === null) {
                  eachr(_this.children, function(childFileWatcher, childFileRelativePath) {
                    if (__indexOf.call(newFileRelativePaths, childFileRelativePath) < 0) {
                      return;
                    }
                    if (!childFileWatcher) {
                      return;
                    }
                    _this.log('debug', 'forwarding extensive change detection to child:', childFileRelativePath, 'via:', fileFullPath);
                    childFileWatcher.listener('change', '.');
                  });
                }
                eachr(_this.children, function(childFileWatcher, childFileRelativePath) {
                  var childFileFullPath;

                  if (__indexOf.call(newFileRelativePaths, childFileRelativePath) >= 0) {
                    return;
                  }
                  childFileFullPath = pathUtil.join(fileFullPath, childFileRelativePath);
                  if (_this.isIgnoredPath(childFileFullPath)) {
                    _this.log('debug', 'ignored delete:', childFileFullPath, 'via:', fileFullPath);
                    return;
                  }
                  _this.log('debug', 'determined delete:', childFileFullPath, 'via:', fileFullPath);
                  _this.closeChild(childFileRelativePath, 'deleted');
                });
                return eachr(newFileRelativePaths, function(childFileRelativePath) {
                  var childFileFullPath;

                  if (_this.children[childFileRelativePath] != null) {
                    return;
                  }
                  _this.children[childFileRelativePath] = false;
                  childFileFullPath = pathUtil.join(fileFullPath, childFileRelativePath);
                  if (_this.isIgnoredPath(childFileFullPath)) {
                    _this.log('debug', 'ignored create:', childFileFullPath, 'via:', fileFullPath);
                    return;
                  }
                  return safefs.stat(childFileFullPath, function(err, childFileStat) {
                    if (err) {
                      return;
                    }
                    _this.log('debug', 'determined create:', childFileFullPath, 'via:', fileFullPath);
                    _this.emitSafe('change', 'create', childFileFullPath, childFileStat, null);
                    _this.watchChild({
                      fullPath: childFileFullPath,
                      relativePath: childFileRelativePath,
                      stat: childFileStat
                    });
                  });
                });
              });
            }
          } else {
            _this.log('debug', 'determined update:', fileFullPath);
            return _this.emitSafe('change', 'update', fileFullPath, currentStat, previousStat);
          }
        }
      }
    };
    safefs.exists(fileFullPath, function(exists) {
      fileExists = exists;
      if (fileExists) {
        return safefs.stat(fileFullPath, function(err, stat) {
          if (err) {
            return _this.emit('error', err);
          }
          currentStat = stat;
          _this.stat = currentStat;
          return determineTheChange();
        });
      } else {
        return determineTheChange();
      }
    });
    return this;
  };

  /*
  	Close
  	We will need something to close our listener for removed or renamed files
  	As renamed files are a bit difficult we will want to close and delete all the watchers for all our children too
  	Essentially it is a self-destruct
  */


  _Class.prototype.close = function(reason) {
    var childRelativePath, _ref;

    if (this.state !== 'active') {
      return this;
    }
    this.log('debug', "close: " + this.path);
    _ref = this.children;
    for (childRelativePath in _ref) {
      if (!__hasProp.call(_ref, childRelativePath)) continue;
      this.closeChild(childRelativePath, reason);
    }
    if (this.method === 'watchFile') {
      fsUtil.unwatchFile(this.path);
    }
    if (this.fswatcher != null) {
      this.fswatcher.close();
      this.fswatcher = null;
    }
    if (reason === 'deleted') {
      this.state = 'deleted';
      this.emitSafe('change', 'delete', this.path, null, this.stat);
    } else if (reason === 'failure') {
      this.state = 'closed';
      this.log('warn', "Failed to watch the path " + this.path);
    } else {
      this.state = 'closed';
    }
    if (watchers[this.path] != null) {
      delete watchers[this.path];
      watchersTotal--;
    }
    return this;
  };

  _Class.prototype.closeChild = function(fileRelativePath, reason) {
    var watcher;

    if (this.children[fileRelativePath] != null) {
      watcher = this.children[fileRelativePath];
      if (watcher) {
        watcher.close(reason);
      }
      delete this.children[fileRelativePath];
    }
    return this;
  };

  /*
  	Watch Child
  	Setup watching for a child
  	Bubble events of the child into our instance
  	Also instantiate the child with our instance's configuration where applicable
  	next(err,watcher)
  */


  _Class.prototype.watchChild = function(opts, next) {
    var config, me, _base, _name;

    me = this;
    config = this.config;
    (_base = me.children)[_name = opts.relativePath] || (_base[_name] = watch({
      path: opts.fullPath,
      stat: opts.stat,
      listeners: {
        'log': me.bubbler('log'),
        'change': function() {
          var args, changeType, path;

          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          changeType = args[0], path = args[1];
          if (changeType === 'delete' && path === opts.fullPath) {
            me.closeChild(opts.relativePath, 'deleted');
          }
          return me.bubble.apply(me, ['change'].concat(__slice.call(args)));
        },
        'error': me.bubbler('error')
      },
      next: next,
      outputLog: config.outputLog,
      interval: config.interval,
      persistent: config.persistent,
      duplicateDelay: config.duplicateDelay,
      preferredMethods: config.preferredMethods,
      ignorePaths: config.ignorePaths,
      ignoreHiddenFiles: config.ignoreHiddenFiles,
      ignoreCommonPatterns: config.ignoreCommonPatterns,
      ignoreCustomPatterns: config.ignoreCustomPatterns
    }));
    return me.children[opts.relativePath];
  };

  /*
  	Watch Children
  	next(err,watching)
  */


  _Class.prototype.watchChildren = function(next) {
    var config, me;

    me = this;
    config = this.config;
    if (this.isDirectory) {
      balUtil.scandir({
        path: this.path,
        ignorePaths: config.ignorePaths,
        ignoreHiddenFiles: config.ignoreHiddenFiles,
        ignoreCommonPatterns: config.ignoreCommonPatterns,
        ignoreCustomPatterns: config.ignoreCustomPatterns,
        recurse: false,
        next: function(err) {
          var watching;

          watching = !err;
          return next(err, watching);
        },
        action: function(fullPath, relativePath, nextFile, stat) {
          if (me.state !== 'active') {
            return nextFile(null, true);
          }
          return me.watchChild({
            fullPath: fullPath,
            relativePath: relativePath,
            stat: stat
          }, function(err, watcher) {
            return nextFile(err);
          });
        }
      });
    } else {
      next(null, true);
    }
    return this;
  };

  /*
  	Watch Self
  */


  _Class.prototype.watchSelf = function(next) {
    var complete, config, me, methodOne, methodTwo, methods;

    me = this;
    config = this.config;
    this.method = null;
    methods = {
      watch: function(next) {
        var err;

        if (fsUtil.watch == null) {
          return next(null, false);
        }
        try {
          me.fswatcher = fsUtil.watch(me.path, me.listener);
        } catch (_error) {
          err = _error;
          return next(err, false);
        }
        me.method = 'watch';
        return next(null, true);
      },
      watchFile: function(next) {
        var err, watchFileOpts;

        if (fsUtil.watchFile == null) {
          return next(null, false);
        }
        watchFileOpts = {
          persistent: config.persistent,
          interval: config.interval
        };
        try {
          fsUtil.watchFile(me.path, watchFileOpts, me.listener);
        } catch (_error) {
          err = _error;
          return next(err, false);
        }
        me.method = 'watchFile';
        return next(null, true);
      }
    };
    complete = function(watching) {
      if (!watching) {
        me.close('failure');
        return next(null, false);
      }
      me.state = 'active';
      return next(null, true);
    };
    methodOne = me.config.preferredMethods[0];
    methodTwo = me.config.preferredMethods[1];
    methods[methodOne](function(err1, watching) {
      if (watching) {
        return complete(watching);
      }
      return methods[methodTwo](function(err2, watching) {
        if (watching) {
          return complete(watching);
        }
        if (err1) {
          me.emit('error', err1);
        }
        if (err2) {
          me.emit('error', err2);
        }
        return complete(false);
      });
    });
    return this;
  };

  /*
  	Watch
  	Setup the native watching handlers for our path so we can receive updates on when things happen
  	If the next argument has been received, then add it is a once listener for the watching event
  	If we are already watching this path then let's start again (call close)
  	If we are a directory, let's recurse
  	If we are deleted, then don't error but return the isWatching argument of our completion callback as false
  	Once watching has completed for this directory and all children, then emit the watching event
  	next(err,watcherInstance,success)
  */


  _Class.prototype.watch = function(next) {
    var complete, config, me,
      _this = this;

    me = this;
    config = this.config;
    if ((this.stat != null) === false) {
      safefs.stat(config.path, function(err, stat) {
        if (err) {
          return _this.emit('error', err);
        }
        _this.stat = stat;
        _this.isDirectory = stat.isDirectory();
        return _this.watch(next);
      });
      return this;
    }
    if (next != null) {
      this.listen('watching', next);
    }
    this.close();
    this.log('debug', "watch: " + this.path);
    complete = function(err, result) {
      if (err == null) {
        err = null;
      }
      if (result == null) {
        result = true;
      }
      if (err || !result) {
        me.close();
        return me.emit('watching', err, me, false);
      } else {
        return me.emit('watching', null, me, true);
      }
    };
    safefs.exists(this.path, function(exists) {
      if (!exists) {
        return complete(null, false);
      }
      return me.watchSelf(function(err, watching) {
        if (err || !watching) {
          return complete(err, watching);
        }
        return me.watchChildren(function(err, watching) {
          return complete(err, watching);
        });
      });
    });
    return this;
  };

  return _Class;

})(EventEmitter);

/*
Create Watcher
Checks to see if the path actually exists, if it doesn't then exit gracefully
If it does exist, then lets check our cache for an already existing watcher instance
If we have an already existing watching instance, then just add our listeners to that
If we don't, then create a watching instance
Fire the next callback once done
next(err,watcherInstance)
*/


createWatcher = function(opts, next) {
  var attempt, listener, listeners, path, watcher;

  path = opts.path, listener = opts.listener, listeners = opts.listeners;
  if (opts.next != null) {
    if (next == null) {
      next = opts.next;
    }
    delete opts.next;
  }
  if (!safefs.existsSync(path)) {
    if (typeof next === "function") {
      next(null, null);
    }
    return;
  }
  if (watchers[path] != null) {
    watcher = watchers[path];
    if (listener) {
      watcher.listen(listener);
    }
    if (listeners) {
      watcher.listen(listeners);
    }
    if (typeof next === "function") {
      next(null, watcher);
    }
  } else {
    attempt = 0;
    watcher = new Watcher(opts, function(err) {
      if (!err || attempt !== 0) {
        return typeof next === "function" ? next(err, watcher) : void 0;
      }
      ++attempt;
      watcher.log('debug', "Preferred method failed, trying methods in reverse order", err);
      return watcher.setup({
        preferredMethods: watcher.config.preferredMethods.reverse()
      }).watch();
    });
    watchers[path] = watcher;
    ++watchersTotal;
  }
  return watcher;
};

/*
Watch
Provides an abstracted API that supports multiple paths
If you are passing in multiple paths then do not rely on the return result containing all of the watchers
you must rely on the result inside the completion callback instead
If you used the paths option, then your results will be an array of watcher instances, otherwise they will be a single watcher instance
next(err,results)
*/


watch = function(opts, next) {
  var paths, result, tasks;

  result = [];
  if (opts.next != null) {
    if (next == null) {
      next = opts.next;
    }
    delete opts.next;
  }
  if (opts.paths) {
    paths = opts.paths;
    delete opts.paths;
    if (typeChecker.isArray(paths)) {
      tasks = new TaskGroup().setConfig({
        concurrency: 0
      }).on('complete', function(err) {
        return typeof next === "function" ? next(err, result) : void 0;
      });
      paths.forEach(function(path) {
        return tasks.addTask(function(complete) {
          var localOpts, watcher;

          localOpts = extendr.extend({}, opts);
          localOpts.path = path;
          watcher = createWatcher(localOpts, complete);
          if (watcher) {
            return result.push(watcher);
          }
        });
      });
      tasks.run();
    } else {
      opts.path = paths;
      result.push(createWatcher(opts, function(err) {
        return typeof next === "function" ? next(err, result) : void 0;
      }));
    }
  } else {
    result = createWatcher(opts, next);
  }
  return result;
};

module.exports = {
  watch: watch,
  Watcher: Watcher
};
